}
Gauss_new(0,0)
Gauss_new(2,2)
bw.estimation=function(X,bw0,cov.data=NULL,lx=100,ly=100,lb=100,ub=400){
# input:
# X:            multivariate point pattern
# pix:          raster image
# Betahat:      estimated beta values
# cov.data:     covariate data for data analysis
# sc.data:      street crime data set that contains the coordinates along with marks
result       = NULL
Cov.image    = X$pix
Beta         = X$Betahat
PP           = X$markedprocess
census.tract = X$censustract
nall       = PP$n
marks      = PP$marks
mval       = levels(marks)
W          = PP$window
aW         = area(W)
p          = length(levels(PP$marks))
len.x      = PP$window$xrange[2] - PP$window$xrange[1]
len.y      = PP$window$yrange[2] - PP$window$yrange[1]
x0         = PP$window$xrange[1]
y0         = PP$window$yrange[1]
gx         = len.x/lx
gy         = len.y/ly
if(is.null(Cov.image)==F){
# Evaluating the covariate wrt. the ith and jth process
Z <- cbind(1,Cov.image[PP])
}
#if(is.null(Cov.image)==T){
#  if(is.null(cov.data)==T){Z= rep(1,n)}
#  else{ Z<- cbind(1,cov.data)}
#}
if(is.null(Cov.image)==T){
# Evaluating the covariate wrt. the ith and jth process
if(is.null(cov.data)==T){Z =rep(1,nall)}
else{Z=cov.data}
}
f =exp(Z%*%Beta)
v =cbind(PP$x,PP$y)
lv <- dim(v)[1]
bw.cvl.new=function(bws){
lamb0=numeric(lv)
for(i in 1:lv){
u=t(replicate(lv,v[i,]))
tmp=0
z=(u-v)
for(k in 1:p){
ind=(marks==mval[k])
#tmp=tmp+sum(ind*Kern_EP_new(z[,1]/bws,z[,2]/bws)/(bws^2*f[,k]))
tmp=tmp+sum(ind*Gauss_new(z[,1]/bws,z[,2]/bws)/(bws^2*f[,k]))
}
# When converting to image, switch of coordinates is needed
lamb0[i]=(1/p)*tmp
}
sum.lamb=0
for(i in 1:p){
ind=(marks==mval[i])
sum.lamb = sum.lamb + sum(1/(lamb0*f[,i])*ind)
}
f.pool=0
for(i in 1:p){f.pool=f.pool + f[,i]}
lamb.pool=lamb0*f.pool
#print(sum(1/lamb.pool))
#print(sum.lamb/p)
#print(aW)
bw.est=(sum(1/lamb.pool)-sum.lamb/p)^2
#bw.est=(aW-sum.lamb/p)^2
print(bw.est)
bw.est
}
#return(bw.cvl.new(bws=100))
# bws=seq(lb,ub,length=10)
# est=c()
# for(i in 1:length(bws)){
#   est[i]=bw.cvl.new(bws=bws[i])
#   print(bws[i])
# }
# #return(est)
# result$bandw  = bws
# result$object = est
# return(result)
bw0           = bw0
bw.est        = optim(par=bw0,fn=bw.cvl.new, method="Brent", lower = lb, upper = ub)
min.bw        = bw.est$par
result$min.bw = min.bw
return(result)
}
bw.est.1=bw.estimation(X0[[1]],bw0=0.25,lb=0.01,ub=0.5)
bw.estimation=function(X,bw0,cov.data=NULL,lx=100,ly=100,lb=100,ub=400){
# input:
# X:            multivariate point pattern
# pix:          raster image
# Betahat:      estimated beta values
# cov.data:     covariate data for data analysis
# sc.data:      street crime data set that contains the coordinates along with marks
result       = NULL
Cov.image    = X$pix
Beta         = X$Betahat
PP           = X$markedprocess
census.tract = X$censustract
nall       = PP$n
marks      = PP$marks
mval       = levels(marks)
W          = PP$window
aW         = area(W)
p          = length(levels(PP$marks))
len.x      = PP$window$xrange[2] - PP$window$xrange[1]
len.y      = PP$window$yrange[2] - PP$window$yrange[1]
x0         = PP$window$xrange[1]
y0         = PP$window$yrange[1]
gx         = len.x/lx
gy         = len.y/ly
if(is.null(Cov.image)==F){
# Evaluating the covariate wrt. the ith and jth process
Z <- cbind(1,Cov.image[PP])
}
#if(is.null(Cov.image)==T){
#  if(is.null(cov.data)==T){Z= rep(1,n)}
#  else{ Z<- cbind(1,cov.data)}
#}
if(is.null(Cov.image)==T){
# Evaluating the covariate wrt. the ith and jth process
if(is.null(cov.data)==T){Z =rep(1,nall)}
else{Z=cov.data}
}
f =exp(Z%*%Beta)
v =cbind(PP$x,PP$y)
lv <- dim(v)[1]
bw.cvl.new=function(bws){
lamb0=numeric(lv)
for(i in 1:lv){
u=t(replicate(lv,v[i,]))
tmp=0
z=(u-v)
for(k in 1:p){
ind=(marks==mval[k])
#tmp=tmp+sum(ind*Kern_EP_new(z[,1]/bws,z[,2]/bws)/(bws^2*f[,k]))
tmp=tmp+sum(ind*Gauss_new(z[,1]/bws,z[,2]/bws)/(bws^2*f[,k]))
}
# When converting to image, switch of coordinates is needed
lamb0[i]=(1/p)*tmp
}
sum.lamb=0
for(i in 1:p){
ind=(marks==mval[i])
sum.lamb = sum.lamb + sum(1/(lamb0*f[,i])*ind)
}
f.pool=0
for(i in 1:p){f.pool=f.pool + f[,i]}
lamb.pool=lamb0*f.pool
#print(sum(1/lamb.pool))
#print(sum.lamb/p)
#print(aW)
bw.est=(sum(1/lamb.pool)-sum.lamb/p)^2
#bw.est=(aW-sum.lamb/p)^2
print(bw.est)
bw.est
}
#return(bw.cvl.new(bws=100))
bws=seq(lb,ub,length=10)
est=c()
for(i in 1:length(bws)){
est[i]=bw.cvl.new(bws=bws[i])
print(bws[i])
}
return(est)
# result$bandw  = bws
# result$object = est
# return(result)
bw0           = bw0
bw.est        = optim(par=bw0,fn=bw.cvl.new, method="Brent", lower = lb, upper = ub)
min.bw        = bw.est$par
result$min.bw = min.bw
return(result)
}
1.36/1.06
1.06/1.36
1.06/2.36
2.36/1.06
Kern_EP_1d=function(x){
(1-(x^2))*3/4*(abs(x)<=1)
}
seq(-1,1,length=100)
r=seq(-1,1,length=100)
plot(r,Kern_EP_1d(r))
Kern_EP_1d(r)
sum(Kern_EP_1d(r))
r=seq(-1,1,length=1000)
sum(Kern_EP_1d(r))
sum(Kern_EP_1d(r))/1000
2*sum(Kern_EP_1d(r))/1000
plot(r,2*Kern_EP_1d(r))
Kern_EP_1d(1)
Kern_EP_1d(0)
Kern_EP_1d(r)
install.packages("epandist")
library(epandist)
depan(1)
depan(0)
depan(1,mu=0.5)
depan(0,mu=0.5)
pepan(0,mu=0.5,r=0.2)
pepan(1,mu=0.5,r=0.2)
pepan(1,mu=0.9,r=0.2)
pepan(1,mu=0.9,r=0.2)-pepan(0,mu=0.9,r=0.2)
pnorm(1,mu=0.9,sd=0.2)
?pnrom
?pnorm
pnorm(1,mean=0.9,sd=0.2)
pnorm(1,mean=0.9,sd=0.1)
pepan(1,mean=0.9,sd=0.1)
pepan(1,mu=0.9,sd=0.1)
pepan(1,mu=0.9,r=0.1)
1e-3
(3.81*1e-4)/(2.22*1e-3)
(2.22*1e-3)/(3.81*1e-4)
(2.63*1e-3)/(3.81*1e-4)
(1.04*1e-3)/(2.01*1e-5)
(2.27*1e-3)/(2.01*1e-5)
?sd
# clean environment
rm(list=ls())
#### LIBRARIES ###################
library(raster)
library(sp)
library(spatstat)
library(RandomFields)
library(parallel)
library(readxl)
library(ggplot2)
library(GET)
##################################
# First order multinomial
code.dir.first.order  <- "~/Documents/R_penalize/first_order/"
source(file=file.path(code.dir.first.order,"first_multinomial.R"))
source(file=file.path(code.dir.first.order,"lambda0.R"))
source(file=file.path(code.dir.first.order,"bandwidth_est_new.R"))
# Second order penalized multinomial
code.dir.second.order <- "~/Documents/R_penalize/second_order/"
source(file=file.path(code.dir.second.order,"second_multinomial.R"))
source(file=file.path(code.dir.second.order,"second_lik.R"))
source(file=file.path(code.dir.second.order,"cross_pcf_ratio.R"))
# Gradients
code.dir.second.order.gradient <- "~/Documents/R_penalize/second_order/estimating_function/"
source(file=file.path(code.dir.second.order.gradient,"grad_alpha.R"))
source(file=file.path(code.dir.second.order.gradient,"grad_log_xi.R"))
source(file=file.path(code.dir.second.order.gradient,"grad_log_sigma2.R"))
source(file=file.path(code.dir.second.order.gradient,"grad_log_phi.R"))
# sensitivities
code.dir.second.order.sen <- "~/Documents/R_penalize/second_order/sensitivity/"
source(file=file.path(code.dir.second.order.sen,"sen_alpha.R"))
source(file=file.path(code.dir.second.order.sen,"sen_xi.R"))
source(file=file.path(code.dir.second.order.sen,"sen_sigma2.R"))
source(file=file.path(code.dir.second.order.sen,"sen_phi.R"))
code.dir.functions  <- "~/Documents/R_penalize/"
source(file=file.path(code.dir.functions,"cross_validation.R"))
source(file=file.path(code.dir.functions,"MISE.R"))
#############################################
View(lambda0)
dir.data <- "~/Documents/R_penalize/data_analysis/lymph_metastasis/"
setwd(dir.data)
load("stroma_cd8.Rdata")
date = Sys.Date()
code.dir6=paste("~/Documents/CC2/penalized/9/figures/data_analysis/","lymph_metastasis/", date,"_strcd8", sep="")
dir.create(code.dir6)
setwd(code.dir6)
lamb0.est=lambda0(data.all.thin,bw=194.5)
library(epandist)
lamb0.est=lambda0(data.all.thin,bw=194.5)
plot(lamb0.est,main="")
#lamb0.est=lambda0(data.all.thin,bw=log(1000))
png("lambda0_stroma.png", width = 600, height = 500)
plot(lamb0.est,main="")
dev.off()
dir.data <- "~/Documents/R_penalize/data_analysis/lymph_metastasis/"
setwd(dir.data)
load("tumor.Rdata")
lamb0.est=lambda0(data.all.tumor,bw=153.3)
plot(lamb0.est,main="")
lambda0=function(X,bw=1,cov.data=NULL,lx=100,ly=100){
Cov.image    = X$pix
Beta         = X$Betahat
PP           = X$markedprocess
census.tract = X$censustract
#return(PP)
n          = PP$n
marks      = PP$marks
mval       = levels(marks)
len.x      = PP$window$xrange[2] - PP$window$xrange[1]
len.y      = PP$window$yrange[2] - PP$window$yrange[1]
x0         = PP$window$xrange[1]
y0         = PP$window$yrange[1]
xN         = PP$window$xrange[2]
yN         = PP$window$yrange[2]
W          = PP$window
gx=len.x/lx
gy=len.y/ly
p = length(levels(PP$marks))
if(is.null(Cov.image)==T){
if(is.null(cov.data)==T){
Z= cbind(rep(1,n))
}
else{
Z<- cov.data
}
}
else{
Z <- cbind(1,Cov.image[PP])
}
v=cbind(PP$x,PP$y)
lamb0=matrix(NA,lx,ly)
for(i in 1:lx){
for(j in 1:ly){
tmp=0
#u=c(x0+i*gx,y0+j*gy)
u=cbind(rep(x0+i*gx,dim(v)[1]),rep(y0+j*gy,dim(v)[1]))
z=(u-v)
for(k in 1:p){
ind=(marks==mval[k])
# pbs1=pnorm(xN,mean=v[,1],sd=bw/2)-pnorm(x0,mean=v[,1],sd=bw/2)
# pbs2=pnorm(yN,mean=v[,2],sd=bw/2)-pnorm(y0,mean=v[,2],sd=bw/2)
pbs1=pepan(xN,mu=v[,1],r=bw)-pepan(x0,mu=v[,1],r=bw)
pbs2=pepan(yN,mu=v[,2],r=bw)-pepan(y0,mu=v[,2],r=bw)
tmp=tmp+sum(ind*Gauss_new(z[,1]/bw,z[,2]/bw)/(pbs1*pbs2*bw^2*exp(Z%*%Beta[,k])))
#tmp=tmp+sum(ind*Kern_EP_new(z[,1]/bw,z[,2]/bw)/(bw^2*exp(Z%*%Beta[,k])))
}
print(c(i,j))
# When converting to image, switch of coordinates is needed
lamb0[j,i]=(1/p)*tmp
}
}
lamb0=as.im(lamb0,W=W)
return(lamb0)
}
lamb0.est=lambda0(data.all.tumor,bw=153.3)
plot(lamb0.est,main="")
data.all.tumor$markedprocess$window
data.all.tumor$markedprocess$window$xrange[2]-data.all.tumor$markedprocess$window$xrange[1]
data.all.tumor$markedprocess$window$yrange[2]-data.all.tumor$markedprocess$window$yrange[1]
lamb0.est=lambda0(data.all.thin,bw=194.5)
plot(lamb0.est,main="")
lamb0.est
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
rpoispp(lamb0.est)
pepan(18390,mu=18300,r=200)
pepan(18390,mu=18000,r=200)
pepan(18390,mu=18200,r=200)
pepan(-11000,mu=18200,r=200)
pepan(0,mu=18200,r=200)
data.all.thin$markedprocess$window$xrange
pepan(-10000,mu=-15000,r=200)
pepan(-10000,mu=-10500,r=200)
pepan(-10000,mu=-10100,r=200)
pepan(-10000,mu=-10200,r=200)
pepan(-10000,mu=-10199,r=200)
lambda0=function(X,bw=1,cov.data=NULL,lx=100,ly=100){
Cov.image    = X$pix
Beta         = X$Betahat
PP           = X$markedprocess
census.tract = X$censustract
#return(PP)
n          = PP$n
marks      = PP$marks
mval       = levels(marks)
len.x      = PP$window$xrange[2] - PP$window$xrange[1]
len.y      = PP$window$yrange[2] - PP$window$yrange[1]
x0         = PP$window$xrange[1]
y0         = PP$window$yrange[1]
xN         = PP$window$xrange[2]
yN         = PP$window$yrange[2]
W          = PP$window
gx=len.x/lx
gy=len.y/ly
p = length(levels(PP$marks))
if(is.null(Cov.image)==T){
if(is.null(cov.data)==T){
Z= cbind(rep(1,n))
}
else{
Z<- cov.data
}
}
else{
Z <- cbind(1,Cov.image[PP])
}
v=cbind(PP$x,PP$y)
lamb0=matrix(NA,lx,ly)
for(i in 1:lx){
for(j in 1:ly){
tmp=0
#u=c(x0+i*gx,y0+j*gy)
u=cbind(rep(x0+i*gx,dim(v)[1]),rep(y0+j*gy,dim(v)[1]))
z=(u-v)
for(k in 1:p){
ind=(marks==mval[k])
# pbs1=pnorm(xN,mean=v[,1],sd=bw/2)-pnorm(x0,mean=v[,1],sd=bw/2)
# pbs2=pnorm(yN,mean=v[,2],sd=bw/2)-pnorm(y0,mean=v[,2],sd=bw/2)
pbs1=pepan(xN,mu=v[,1],r=bw)-pepan(x0,mu=v[,1],r=bw)
pbs2=pepan(yN,mu=v[,2],r=bw)-pepan(y0,mu=v[,2],r=bw)
tmp=tmp+sum(ind*Kern_EP_new(z[,1]/bw,z[,2]/bw)/(pbs1*pbs2*bw^2*exp(Z%*%Beta[,k])))
#tmp=tmp+sum(ind*Kern_EP_new(z[,1]/bw,z[,2]/bw)/(bw^2*exp(Z%*%Beta[,k])))
}
print(c(i,j))
# When converting to image, switch of coordinates is needed
lamb0[j,i]=(1/p)*tmp
}
}
lamb0=as.im(lamb0,W=W)
return(lamb0)
}
lamb0.est=lambda0(data.all.thin,bw=194.5)
plot(lamb0.est,main="")
#lamb0.est=lambda0(data.all.thin,bw=log(1000))
png("lambda0_stroma.png", width = 600, height = 500)
plot(lamb0.est,main="")
dev.off()
lamb0.est=lambda0(data.all.tumor,bw=153.3)
plot(lamb0.est,main="")
#lamb0.est=lambda0(data.all.thin,bw=log(1000))
png("lambda0_tumor.png", width = 600, height = 500)
plot(lamb0.est,main="")
dev.off()
getwd()
library(Multilogreg)
devtools::load_all(".")
library(Multilogreg)
devtools::load_all(".")
document()
library(devtools)
document()
library(roxygen2)
document()
build()
install()
install()
document()
check()
check()
check()
build()
install()
document()
document()
install()
check()
document()
document()
install()
build()
build()
install()
document()
check()
document()
document()
document()
build()
install()
check()
build()
install()
check()
document()
check()
check
check()
document()
build()
install()
check()
check()
check()
check()
check()
install()
check()
build()
install()
check()
document()
build()
install()
check()
build()
install()
check()
library(Multilogreg)
library(Multilogreg)
check()
build()
check()
library(Multilogreg)
?rpoispp()
?rpoispp()
library(Multilogreg)
check()
library(Multilogreg)
?PenalizedSecondOrderCCL
library(Multilogreg)
check()
library(Multilogreg)
?rLGCP()
